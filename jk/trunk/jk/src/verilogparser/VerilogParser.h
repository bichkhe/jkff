/**
 * @file   VerilogParser.h
 * @author Minh D. Nguyen
 * @date   Tue Apr  3 10:42:10 2012
 * 
 * @brief  Wrapper for verilog parser functions generated by bison
 * 
 * 
 */


#ifndef __VERILOG_PARSER_H__
#define __VERILOG_PARSER_H__

#include <string>
#include <map>
#include <list>
#include <vector>
#include <iostream>
#include <fstream>

#include "VerilogFactory.h"
#include "VerilogAst.h"

class VerilogScanner;

//! \brief This is the Verilog Parser class. It uses a \a VerilogFactory to
//! to tell the user what has been parsed. On errors a \a VerilogException is thrown.
class VerilogParser {
public:	//constructors
	//! Constructs an VerilogParser using the factory interface (\a VerilogFactory).
	//! \param factory An implementation of \a VerilogFactory to be used during \a parse().
  VerilogParser(VerilogFactory* factory, std::string logFilename="verilogparser.log");
	~VerilogParser();

public: //methods
	//! Parse verilog file format from stream and drive \a VerilogFactory.
	//! \param inputstream Input stream containing GAT file.
	//! \return true on case of success.
	//! \throw VerilogException in case of an error.
	bool parse(std::istream& inputstream);

private: //methods
	int yylex();
	int yyparse(void);
	void yyerror(const char*) const;
	// unsigned TwoPowX(unsigned x) const;
	// unsigned toUnsigned(const std::string& value_of_constant) const;
public:
	void YYTRACE(const char* msg) const;
	char* processWhite(char* const str);
	void parseInclude(const char* file);

//==========lex and yacc===========//
	string yyid;
   unsigned short lineNo;
   unsigned short  colNo;
   
   bool defState;
   bool blackBox;
   bool vLibComment;
   bool modStart;
   bool isInclude;
   bool isInteger;
   int defCount;
   VerilogNode* currentModulePtr;
   VerilogNode* currentPtr;

enum ScopeState
{
   MODULE      = 0,
   TASK        = 1,
   FUNCTION    = 2
};

enum ProcessState
{
   EVENT       = 0,
   ASSIGN      = 1,
   IO          = 2,
   NET         = 3,
   REG         = 4,
   INT         = 5,
   PARAM       = 6,
   PARAM_NOL   = 7,
   DEFINE      = 8,
   S_NULL      = 9
};

   enum ProcessState state;
   enum ScopeState   scopeState;
	 
   // stack<YY_BUFFER_STATE> LexBufStack;
   // stack<FILE*>  FILEStack;
   // stack<short>  LNStack;
   // stack<short>  CNStack;
   // stack<string> FileNameStack;//STL
	 
	 /// output of parser
       std::ofstream mLogStream;

	VerilogFactory*						mFactory;
	/// Store ASTs that are created when verilog files are parsed. Each AST corresponds to a file.
	std::vector<VerilogAst*>		mResults; // ?? can suy nghi them ve cai nay
	VerilogScanner*           mScanner;
};


#endif
